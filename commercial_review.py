"""
================================================================================
COMMERCIAL REVIEW SYSTEM
================================================================================
Manages the review queue and publish workflow for AI-generated commercials.

Flow:
1. Commercials generated by RAGNAROK go to "review" status (not public)
2. Internal review via Command Center
3. "Publish" sends to video-preview-theta.vercel.app
4. Optional client notification

Statuses:
- generating: RAGNAROK pipeline running
- review: Ready for internal review (default after generation)
- published: Sent to video preview app
- delivered: Client notified
- rejected: Did not pass review

Author: Barrios A2I | Version: 1.0.0 | January 2026
================================================================================
"""

import asyncio
import json
import logging
import time
import uuid
import os
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from typing import Dict, Any, Optional, List

import httpx

logger = logging.getLogger(__name__)


# =============================================================================
# DATA MODELS
# =============================================================================

class CommercialStatus(Enum):
    """Commercial review status lifecycle"""
    GENERATING = "generating"      # RAGNAROK pipeline running
    REVIEW = "review"              # Ready for internal review
    PUBLISHED = "published"        # Sent to video preview app
    DELIVERED = "delivered"        # Client notified
    REJECTED = "rejected"          # Did not pass review


@dataclass
class Commercial:
    """Commercial record with full metadata"""
    id: str
    session_id: str
    title: str
    status: CommercialStatus

    # Video data
    video_url: str
    thumbnail_url: Optional[str] = None
    duration_seconds: int = 30

    # Business context
    business_name: str = ""
    industry: str = ""
    client_email: Optional[str] = None

    # Metadata
    created_at: float = field(default_factory=time.time)
    updated_at: float = field(default_factory=time.time)
    published_at: Optional[float] = None
    delivered_at: Optional[float] = None

    # Review notes
    review_notes: str = ""
    rejection_reason: str = ""

    # Pipeline data
    pipeline_cost_usd: float = 0.0
    pipeline_duration_ms: float = 0.0

    # Platform variants
    formats: Dict[str, str] = field(default_factory=dict)  # format -> url

    # Tags for filtering
    tags: List[str] = field(default_factory=lambda: ["commercial"])

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary"""
        return {
            "id": self.id,
            "session_id": self.session_id,
            "title": self.title,
            "status": self.status.value,
            "video_url": self.video_url,
            "thumbnail_url": self.thumbnail_url,
            "duration_seconds": self.duration_seconds,
            "business_name": self.business_name,
            "industry": self.industry,
            "client_email": self.client_email,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
            "published_at": self.published_at,
            "delivered_at": self.delivered_at,
            "review_notes": self.review_notes,
            "rejection_reason": self.rejection_reason,
            "pipeline_cost_usd": self.pipeline_cost_usd,
            "pipeline_duration_ms": self.pipeline_duration_ms,
            "formats": self.formats,
            "tags": self.tags,
            # Computed fields
            "created_at_iso": datetime.fromtimestamp(self.created_at).isoformat(),
            "duration_formatted": f"{self.duration_seconds // 60}:{self.duration_seconds % 60:02d}"
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Commercial":
        """Deserialize from dictionary"""
        status = data.get("status", "review")
        if isinstance(status, str):
            status = CommercialStatus(status)

        return cls(
            id=data.get("id", str(uuid.uuid4())),
            session_id=data.get("session_id", ""),
            title=data.get("title", "Untitled Commercial"),
            status=status,
            video_url=data.get("video_url", ""),
            thumbnail_url=data.get("thumbnail_url"),
            duration_seconds=data.get("duration_seconds", 30),
            business_name=data.get("business_name", ""),
            industry=data.get("industry", ""),
            client_email=data.get("client_email"),
            created_at=data.get("created_at", time.time()),
            updated_at=data.get("updated_at", time.time()),
            published_at=data.get("published_at"),
            delivered_at=data.get("delivered_at"),
            review_notes=data.get("review_notes", ""),
            rejection_reason=data.get("rejection_reason", ""),
            pipeline_cost_usd=data.get("pipeline_cost_usd", 0.0),
            pipeline_duration_ms=data.get("pipeline_duration_ms", 0.0),
            formats=data.get("formats", {}),
            tags=data.get("tags", ["commercial"])
        )


# =============================================================================
# VIDEO PREVIEW APP CLIENT
# =============================================================================

class VideoPreviewClient:
    """
    Client for publishing commercials to video-preview-theta.vercel.app
    """

    def __init__(self, base_url: str = None):
        self.base_url = base_url or os.getenv(
            "VIDEO_PREVIEW_URL",
            "https://video-preview-theta.vercel.app"
        )
        self.api_key = os.getenv("VIDEO_PREVIEW_API_KEY", "")

    async def publish_video(self, commercial: Commercial) -> Dict[str, Any]:
        """
        Publish a commercial to the video preview app.

        Returns:
            dict with preview_url and success status
        """
        payload = {
            "id": commercial.id,
            "title": commercial.title,
            "description": f"AI-generated commercial for {commercial.business_name}",
            "url": commercial.video_url,
            "thumbnail": commercial.thumbnail_url,
            "duration": f"{commercial.duration_seconds // 60}:{commercial.duration_seconds % 60:02d}",
            "created": datetime.fromtimestamp(commercial.created_at).strftime("%Y-%m-%d"),
            "tags": commercial.tags + [commercial.industry] if commercial.industry else commercial.tags,
            "business_name": commercial.business_name,
            "industry": commercial.industry
        }

        headers = {"Content-Type": "application/json"}
        if self.api_key:
            headers["Authorization"] = f"Bearer {self.api_key}"

        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    f"{self.base_url}/api/videos",
                    json=payload,
                    headers=headers
                )

                if response.status_code in [200, 201]:
                    result = response.json()
                    logger.info(f"Published commercial {commercial.id} to video preview app")
                    return {
                        "success": True,
                        "preview_url": f"{self.base_url}/gallery.html#{commercial.id}",
                        "response": result
                    }
                else:
                    logger.error(f"Publish failed: {response.status_code} - {response.text}")
                    return {
                        "success": False,
                        "error": f"HTTP {response.status_code}: {response.text}"
                    }

        except httpx.RequestError as e:
            logger.error(f"Network error publishing commercial: {e}")
            return {
                "success": False,
                "error": f"Network error: {str(e)}"
            }
        except Exception as e:
            logger.error(f"Error publishing commercial: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def get_gallery_url(self, commercial_id: str) -> str:
        """Get the gallery URL for a specific commercial"""
        return f"{self.base_url}/gallery.html#{commercial_id}"


# =============================================================================
# EMAIL NOTIFICATION CLIENT
# =============================================================================

class NotificationClient:
    """
    Sends notifications to clients when their commercial is ready.
    Uses SendGrid or similar email service.
    """

    def __init__(self):
        self.sendgrid_key = os.getenv("SENDGRID_API_KEY")
        self.from_email = os.getenv("NOTIFICATION_FROM_EMAIL", "noreply@barriosa2i.com")
        self.enabled = bool(self.sendgrid_key)

    async def notify_client(
        self,
        commercial: Commercial,
        preview_url: str
    ) -> Dict[str, Any]:
        """
        Send email notification to client about their commercial.
        """
        if not self.enabled:
            logger.warning("Email notifications disabled (no SENDGRID_API_KEY)")
            return {"success": False, "error": "Notifications disabled"}

        if not commercial.client_email:
            return {"success": False, "error": "No client email provided"}

        try:
            # Import sendgrid only when needed
            import sendgrid
            from sendgrid.helpers.mail import Mail, Email, To, Content

            sg = sendgrid.SendGridAPIClient(api_key=self.sendgrid_key)

            message = Mail(
                from_email=Email(self.from_email, "Barrios A2I"),
                to_emails=To(commercial.client_email),
                subject=f"Your Commercial is Ready: {commercial.title}",
                html_content=self._build_email_html(commercial, preview_url)
            )

            response = sg.send(message)

            logger.info(f"Sent notification to {commercial.client_email}")
            return {
                "success": True,
                "status_code": response.status_code
            }

        except Exception as e:
            logger.error(f"Failed to send notification: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def _build_email_html(self, commercial: Commercial, preview_url: str) -> str:
        """Build HTML email content"""
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {{ font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #0A1628; color: white; padding: 40px; }}
                .container {{ max-width: 600px; margin: 0 auto; }}
                .logo {{ font-size: 2rem; font-weight: 700; background: linear-gradient(90deg, #00CED1, #FFD700); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }}
                .card {{ background: rgba(0, 206, 209, 0.1); border: 1px solid rgba(0, 206, 209, 0.3); border-radius: 16px; padding: 30px; margin: 20px 0; }}
                .btn {{ display: inline-block; background: linear-gradient(90deg, #00CED1, #00a8aa); color: #0A1628; padding: 14px 28px; border-radius: 8px; font-weight: 600; text-decoration: none; }}
                .meta {{ color: #8892a4; font-size: 0.9rem; }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="logo">BARRIOS A2I</div>
                <h1>Your Commercial is Ready!</h1>

                <div class="card">
                    <h2>{commercial.title}</h2>
                    <p class="meta">Business: {commercial.business_name}</p>
                    <p class="meta">Duration: {commercial.duration_seconds}s</p>
                    <p class="meta">Industry: {commercial.industry}</p>
                </div>

                <p>Your AI-generated commercial has been reviewed and is ready for viewing.</p>

                <a href="{preview_url}" class="btn">View Your Commercial</a>

                <p class="meta" style="margin-top: 40px;">
                    Questions? Reply to this email or visit <a href="https://barriosa2i.com" style="color: #00CED1;">barriosa2i.com</a>
                </p>
            </div>
        </body>
        </html>
        """


# =============================================================================
# COMMERCIAL REVIEW MANAGER
# =============================================================================

class CommercialReviewManager:
    """
    Manages the commercial review queue and publish workflow.

    Responsibilities:
    - Track all commercials with their review status
    - Queue management (filter by status)
    - Publish workflow (send to video preview app)
    - Client notifications
    - Rejection handling
    """

    def __init__(self, redis_client=None):
        self.redis = redis_client
        self.commercials: Dict[str, Commercial] = {}
        self.video_preview = VideoPreviewClient()
        self.notifications = NotificationClient()

        # Redis key prefix
        self.redis_prefix = "commercial:review:"

        logger.info("CommercialReviewManager initialized")

    # =========================================================================
    # COMMERCIAL CRUD
    # =========================================================================

    async def create_commercial(
        self,
        session_id: str,
        title: str,
        video_url: str,
        business_name: str = "",
        industry: str = "",
        client_email: str = None,
        thumbnail_url: str = None,
        duration_seconds: int = 30,
        pipeline_cost_usd: float = 0.0,
        pipeline_duration_ms: float = 0.0,
        formats: Dict[str, str] = None,
        tags: List[str] = None
    ) -> Commercial:
        """
        Create a new commercial in REVIEW status.
        Called after RAGNAROK pipeline completes.
        """
        commercial_id = f"{business_name.lower().replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        commercial_id = commercial_id[:50]  # Limit length

        commercial = Commercial(
            id=commercial_id,
            session_id=session_id,
            title=title,
            status=CommercialStatus.REVIEW,  # Default to review queue
            video_url=video_url,
            thumbnail_url=thumbnail_url,
            duration_seconds=duration_seconds,
            business_name=business_name,
            industry=industry,
            client_email=client_email,
            pipeline_cost_usd=pipeline_cost_usd,
            pipeline_duration_ms=pipeline_duration_ms,
            formats=formats or {},
            tags=tags or ["commercial"]
        )

        # Store in memory
        self.commercials[commercial_id] = commercial

        # Store in Redis if available
        await self._save_to_redis(commercial)

        logger.info(f"Created commercial {commercial_id} in REVIEW status")
        return commercial

    async def get_commercial(self, commercial_id: str) -> Optional[Commercial]:
        """Get a commercial by ID"""
        # Check memory first
        if commercial_id in self.commercials:
            return self.commercials[commercial_id]

        # Check Redis
        commercial = await self._load_from_redis(commercial_id)
        if commercial:
            self.commercials[commercial_id] = commercial
            return commercial

        return None

    async def update_commercial(
        self,
        commercial_id: str,
        updates: Dict[str, Any]
    ) -> Optional[Commercial]:
        """Update a commercial's fields"""
        commercial = await self.get_commercial(commercial_id)
        if not commercial:
            return None

        # Apply updates
        for key, value in updates.items():
            if hasattr(commercial, key):
                if key == "status" and isinstance(value, str):
                    value = CommercialStatus(value)
                setattr(commercial, key, value)

        commercial.updated_at = time.time()

        # Save
        self.commercials[commercial_id] = commercial
        await self._save_to_redis(commercial)

        return commercial

    # =========================================================================
    # QUEUE MANAGEMENT
    # =========================================================================

    async def get_review_queue(
        self,
        status: Optional[CommercialStatus] = None,
        industry: Optional[str] = None,
        limit: int = 50,
        offset: int = 0
    ) -> List[Commercial]:
        """
        Get commercials from the review queue.

        Args:
            status: Filter by status (default: REVIEW)
            industry: Filter by industry
            limit: Max results
            offset: Pagination offset
        """
        # Load all from Redis if needed
        await self._sync_from_redis()

        results = []
        for commercial in self.commercials.values():
            # Apply filters
            if status and commercial.status != status:
                continue
            if industry and commercial.industry != industry:
                continue
            results.append(commercial)

        # Sort by created_at descending (newest first)
        results.sort(key=lambda c: c.created_at, reverse=True)

        # Apply pagination
        return results[offset:offset + limit]

    async def get_queue_stats(self) -> Dict[str, Any]:
        """Get statistics about the review queue"""
        await self._sync_from_redis()

        stats = {
            "total": len(self.commercials),
            "by_status": {},
            "by_industry": {}
        }

        for commercial in self.commercials.values():
            # Count by status
            status = commercial.status.value
            stats["by_status"][status] = stats["by_status"].get(status, 0) + 1

            # Count by industry
            industry = commercial.industry or "unknown"
            stats["by_industry"][industry] = stats["by_industry"].get(industry, 0) + 1

        return stats

    # =========================================================================
    # PUBLISH WORKFLOW
    # =========================================================================

    async def publish_commercial(
        self,
        commercial_id: str,
        notify_client: bool = False
    ) -> Dict[str, Any]:
        """
        Publish a commercial to the video preview app.

        Steps:
        1. Validate commercial is in REVIEW status
        2. Send to video-preview-theta.vercel.app
        3. Update status to PUBLISHED
        4. Optionally notify client

        Returns:
            Result dict with preview_url and success status
        """
        commercial = await self.get_commercial(commercial_id)
        if not commercial:
            return {"success": False, "error": "Commercial not found"}

        if commercial.status != CommercialStatus.REVIEW:
            return {
                "success": False,
                "error": f"Cannot publish commercial in {commercial.status.value} status"
            }

        # Step 1: Publish to video preview app
        result = await self.video_preview.publish_video(commercial)

        if not result["success"]:
            return result

        # Step 2: Update status
        commercial.status = CommercialStatus.PUBLISHED
        commercial.published_at = time.time()
        commercial.updated_at = time.time()

        self.commercials[commercial_id] = commercial
        await self._save_to_redis(commercial)

        logger.info(f"Published commercial {commercial_id}")

        # Step 3: Notify client if requested
        if notify_client and commercial.client_email:
            notify_result = await self.notifications.notify_client(
                commercial,
                result["preview_url"]
            )

            if notify_result["success"]:
                commercial.status = CommercialStatus.DELIVERED
                commercial.delivered_at = time.time()
                commercial.updated_at = time.time()
                self.commercials[commercial_id] = commercial
                await self._save_to_redis(commercial)

            result["notification"] = notify_result

        return {
            "success": True,
            "commercial_id": commercial_id,
            "status": commercial.status.value,
            "preview_url": result["preview_url"],
            "notification": result.get("notification")
        }

    async def reject_commercial(
        self,
        commercial_id: str,
        reason: str = ""
    ) -> Dict[str, Any]:
        """
        Reject a commercial from the review queue.
        """
        commercial = await self.get_commercial(commercial_id)
        if not commercial:
            return {"success": False, "error": "Commercial not found"}

        commercial.status = CommercialStatus.REJECTED
        commercial.rejection_reason = reason
        commercial.updated_at = time.time()

        self.commercials[commercial_id] = commercial
        await self._save_to_redis(commercial)

        logger.info(f"Rejected commercial {commercial_id}: {reason}")

        return {
            "success": True,
            "commercial_id": commercial_id,
            "status": commercial.status.value
        }

    # =========================================================================
    # REDIS STORAGE
    # =========================================================================

    async def _save_to_redis(self, commercial: Commercial):
        """Save commercial to Redis"""
        if not self.redis:
            return

        try:
            key = f"{self.redis_prefix}{commercial.id}"
            await self.redis.set(
                key,
                json.dumps(commercial.to_dict()),
                ex=86400 * 30  # 30 day expiry
            )
        except Exception as e:
            logger.warning(f"Failed to save to Redis: {e}")

    async def _load_from_redis(self, commercial_id: str) -> Optional[Commercial]:
        """Load commercial from Redis"""
        if not self.redis:
            return None

        try:
            key = f"{self.redis_prefix}{commercial_id}"
            data = await self.redis.get(key)
            if data:
                return Commercial.from_dict(json.loads(data))
        except Exception as e:
            logger.warning(f"Failed to load from Redis: {e}")

        return None

    async def _sync_from_redis(self):
        """Sync all commercials from Redis to memory"""
        if not self.redis:
            return

        try:
            pattern = f"{self.redis_prefix}*"
            keys = []
            async for key in self.redis.scan_iter(match=pattern):
                keys.append(key)

            for key in keys:
                data = await self.redis.get(key)
                if data:
                    commercial = Commercial.from_dict(json.loads(data))
                    self.commercials[commercial.id] = commercial

        except Exception as e:
            logger.warning(f"Failed to sync from Redis: {e}")


# =============================================================================
# FACTORY FUNCTION
# =============================================================================

def create_review_manager(redis_client=None) -> CommercialReviewManager:
    """Create a CommercialReviewManager instance"""
    return CommercialReviewManager(redis_client=redis_client)


# =============================================================================
# INTEGRATION WITH NEXUS BRIDGE
# =============================================================================

async def on_production_complete(
    review_manager: CommercialReviewManager,
    session_id: str,
    result: Dict[str, Any],
    brief: Dict[str, Any]
) -> Commercial:
    """
    Hook called when RAGNAROK production completes.
    Creates a commercial in the review queue.

    Args:
        review_manager: The review manager instance
        session_id: Production session ID
        result: RAGNAROK production result
        brief: Original creative brief

    Returns:
        Created Commercial object
    """
    # Extract video URL from result
    video_urls = result.get("video_urls", {})
    primary_url = (
        video_urls.get("youtube_1080p") or
        video_urls.get("r2_url") or
        list(video_urls.values())[0] if video_urls else ""
    )

    # Create commercial in review queue
    commercial = await review_manager.create_commercial(
        session_id=session_id,
        title=f"{brief.get('business_name', 'Unknown')} Commercial",
        video_url=primary_url,
        business_name=brief.get("business_name", ""),
        industry=brief.get("industry", ""),
        client_email=brief.get("client_email"),
        thumbnail_url=result.get("thumbnail_url"),
        duration_seconds=brief.get("duration_seconds", 30),
        pipeline_cost_usd=result.get("total_cost_usd", 0),
        pipeline_duration_ms=result.get("total_duration_ms", 0),
        formats=video_urls,
        tags=["commercial", brief.get("industry", "general")]
    )

    return commercial
